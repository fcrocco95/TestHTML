<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <title>Codice examLIS</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      background-color: #f4f4f4;
      margin: 40px;
    }
    h1 {
      color: #333;
    }
    pre {
      background-color: #272822;
      color: #f8f8f2;
      padding: 20px;
      border-radius: 8px;
      overflow-x: auto;
    }
    .comment {
      color: #75715e;
    }
    .keyword {
      color: #66d9ef;
    }
    .string {
      color: #e6db74;
    }
    .function {
      color: #a6e22e;
    }
  </style>
</head>
<body>

  <h1>Funzione <code>examLIS</code> con gestione speciale del conteggio</h1>

  <pre><code><span class="keyword">def</span> <span class="function">examLIS</span>(A):
    n = <span class="keyword">len</span>(A)
    dp = [1] * n
    cnt = [1] * n
    prev = [-1] * n

    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(n):
        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="keyword">range</span>(i):
            <span class="keyword">if</span> A[j] &lt; A[i]:
                <span class="keyword">if</span> dp[j] + 1 &gt; dp[i]:
                    dp[i] = dp[j] + 1
                    <span class="comment"># Fix per la corretta gestione se le ultime 2 cifre sono (5,6) || (11,12)</span>
                    <span class="keyword">if</span> A[i] != A[-1]:
                        cnt[i] = cnt[j]
                    prev[i] = j
                <span class="keyword">elif</span> dp[j] + 1 == dp[i]:
                    cnt[i] = (cnt[i] + cnt[j]) % 10**7

    opt_val = <span class="keyword">max</span>(dp)
    indices = [i <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(n) <span class="keyword">if</span> dp[i] == opt_val]
    num_sols = <span class="keyword">sum</span>(cnt[i] <span class="keyword">for</span> i <span class="keyword">in</span> indices) % 10**7

    <span class="comment"># Reconstruct phase</span>
    i = indices[0]
    opt_sol = []
    <span class="keyword">while</span> i != -1:
        opt_sol.append(A[i])
        i = prev[i]
    opt_sol.reverse()

    <span class="keyword">return</span> opt_val, opt_sol, num_sols
</code></pre>

  <h1>Funzione <code>graphExplorerDFSPlusVincoliLabels</code> e uso</h1>

  <pre><code><span class="keyword">graph</span> = {
    0: [(1,2), (2,3)],
    1: [(3,2), (4,4)],
    2: [(4,2)],
    3: [(5,3)],
    4: [(5,1)],
    5: []
}

labels = [10, 20, 15, 25, 30, 35]
start = 0
end = <span class="keyword">len</span>(graph) - 1

min_weight, best_path, ways = <span class="function">graphExplorerDFSPlusVincoliLabels</span>(graph, labels, start, end)

<span class="keyword">print</span>("Peso minimo:", min_weight)
<span class="keyword">print</span>("Percorso ottimo:", best_path)
<span class="keyword">print</span>("Numero di percorsi ottimali:", ways)


<span class="keyword">def</span> <span class="function">graphExplorerDFSPlusVincoliLabels</span>(graph, labels, start, end):
    MOD = 10**7
    visited = [<span class="keyword">False</span>] * <span class="keyword">len</span>(graph)
    path = []
    best_path = []
    min_weight = <span class="keyword">float</span>('inf')
    ways = 0

    <span class="keyword">def</span> DFS(u, curr_weight):
        <span class="keyword">nonlocal</span> min_weight, best_path, ways
        path.append(u)
        visited[u] = <span class="keyword">True</span>

        <span class="keyword">if</span> u == end:
            <span class="keyword">if</span> curr_weight &lt; min_weight:
                min_weight = curr_weight
                best_path = <span class="keyword">list</span>(path)
                ways = 1
            <span class="keyword">elif</span> curr_weight == min_weight:
                ways = (ways + 1) % MOD
        <span class="keyword">else</span>:
            <span class="keyword">for</span> v, w <span class="keyword">in</span> graph[u]:
                <span class="keyword">if</span> <span class="keyword">not</span> visited[v] <span class="keyword">and</span> labels[v] &gt; labels[u]:
                    DFS(v, curr_weight + w)

        path.pop()
        visited[u] = <span class="keyword">False</span>

    DFS(start, 0)
    <span class="keyword">return</span> min_weight, best_path, ways
</code></pre>


<h1>Funzione <code>dikstraSolver</code>: calcolo cammini minimi da nodo 0</h1>

<pre><code><span class="keyword">def</span> <span class="function">dikstraSolver</span>(n, out_nei):
    dist = [<span class="keyword">float</span>('inf')] * n
    num_shortest_paths = [0] * n
    all_parents = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="keyword">range</span>(n)]
    chosen_parent = [0] * n

    dist[0] = 0
    num_shortest_paths[0] = 1
    heap = [(0, 0)]

    <span class="comment"># Algoritmo di Dijkstra</span>
    <span class="keyword">while</span> heap:
        d, u = heapq.heappop(heap)
        <span class="keyword">if</span> d &gt; dist[u]:
            <span class="keyword">continue</span>

        <span class="keyword">for</span> v, weight <span class="keyword">in</span> out_nei[u]:
            new_dist = dist[u] + weight
            <span class="keyword">if</span> dist[v] &gt; new_dist:
                dist[v] = new_dist
                num_shortest_paths[v] = num_shortest_paths[u]
                all_parents[v] = [u]
                heapq.heappush(heap, (dist[v], v))
            <span class="keyword">elif</span> dist[v] == new_dist:
                num_shortest_paths[v] = (num_shortest_paths[v] + num_shortest_paths[u]) % MOD
                all_parents[v].append(u)

    <span class="comment"># Costruzione dell'albero dei cammini minimi</span>
    <span class="keyword">for</span> v <span class="keyword">in</span> <span class="keyword">range</span>(1, n):
        chosen_parent[v] = <span class="keyword">min</span>(all_parents[v])

    num_trees = 1
    <span class="keyword">for</span> v <span class="keyword">in</span> <span class="keyword">range</span>(1, n):
        <span class="keyword">if</span> <span class="keyword">not</span> all_parents[v]:
            num_trees = 0
            <span class="keyword">break</span>
        <span class="keyword">if</span> <span class="keyword">len</span>(<span class="keyword">set</span>(all_parents[v])) &gt; 1:
            <span class="keyword">continue</span>

    <span class="keyword">return</span> dist, chosen_parent, num_trees
</code></pre>

</body>
</html>
